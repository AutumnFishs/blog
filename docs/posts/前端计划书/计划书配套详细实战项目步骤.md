# é˜¶æ®µä¸€ï¼šNode.jsä¸“è®­ - æ™ºèƒ½æ—¥å¿—åˆ†æç³»ç»Ÿ
## ğŸ› ï¸ é¡¹ç›®æ­¥éª¤è¯¦è§£
### æ­¥éª¤1ï¼šç¯å¢ƒåˆå§‹åŒ–ï¼ˆ30åˆ†é’Ÿï¼‰
``` sh
# åˆå§‹åŒ–é¡¹ç›®
mkdir log-analyzer && cd log-analyzer
npm init -y
# å…³é”®ä¾èµ–
npm install chokidar dayjs csv-parser lodash chalk
```

### æ­¥éª¤2ï¼šæ—¥å¿—ç›‘å¬æ¨¡å—ï¼ˆæ ¸å¿ƒï¼‰
``` js
// watcher.js
const chokidar = require('chokidar');

class LogWatcher {
  constructor(logDir) {
    this.watcher = chokidar.watch(logDir, {
      ignored: /(^|[/\\])\../, // å¿½ç•¥éšè—æ–‡ä»¶
      persistent: true,
    });
    
    this.watcher
      .on('add', path => this.handleNewLog(path))
      .on('change', path => this.handleLogUpdate(path));
  }

  handleNewLog(path) {
    const stream = fs.createReadStream(path);
    // é€šè¿‡ç®¡é“ä¼ é€’åˆ°åˆ†ææ¨¡å—
    stream.pipe(createAnalyzerPipeline());
  }
}

module.exports = LogWatcher;
```
### æ­¥éª¤3ï¼šæ„å»ºæµå¼å¤„ç†ç®¡é“
``` js
// analyzer.js
const { Transform } = require('stream');
const csv = require('csv-parser');

function createAnalyzerPipeline() {
  // CSVè§£æè½¬æ¢æµ
  const csvParser = csv();
  
  // é”™è¯¯æ—¥å¿—è¿‡æ»¤
  const errorFilter = new Transform({
    objectMode: true,
    transform(chunk, encoding, callback) {
      if (chunk.level === 'ERROR') this.push(chunk);
      callback();
    }
  });

  // èšåˆç»Ÿè®¡
  const errorCounter = new Transform({
    objectMode: true,
    transform(chunk, encoding, callback) {
      this.totalErrors = (this.totalErrors || 0) + 1;
      callback();
    },
    flush(callback) {
      console.log(`å‘ç° ${this.totalErrors} æ¡é”™è¯¯æ—¥å¿—`);
      callback();
    }
  });

  return csvParser
    .pipe(errorFilter)
    .pipe(errorCounter);
}
```

### æ­¥éª¤4ï¼šå¯åŠ¨æœåŠ¡ï¼ˆè¿›é˜¶ï¼‰
``` js
// index.js
const LogWatcher = require('./watcher');
const analyzer = require('./analyzer');

// å¯åŠ¨ç›‘å¬
new LogWatcher('./logs');

// Workerçº¿ç¨‹å¤„ç†æ•°æ®
const { Worker } = require('worker_threads');
const reportWorker = new Worker('./report-generator.js');
```
**å…³é”®æŒ‘æˆ˜ï¼š**

- å¤§æ–‡ä»¶å†…å­˜æ§åˆ¶ï¼ˆä½¿ç”¨streamèƒŒå‹æœºåˆ¶ï¼‰
- æ—¥å¿—æ ¼å¼å…¼å®¹æ€§ï¼ˆä½¿ç”¨é€‚é…å™¨æ¨¡å¼ï¼‰
- å¤šçº¿ç¨‹æ•°æ®é€šä¿¡ï¼ˆSharedArrayBufferæˆ–æ¶ˆæ¯ç«¯å£ï¼‰

## é˜¶æ®µäºŒï¼šNestJSå®æˆ˜ - ç”µå•†ç®¡ç†ç³»ç»Ÿ
### ğŸ§© å¼€å‘æ­¥éª¤åˆ†è§£
``` markdown
Moduleç»“æ„è§„åˆ’
src/
â”œâ”€â”€ products
â”‚   â”œâ”€â”€ dto
â”‚   â”‚   â”œâ”€â”€ create-product.dto.ts
â”‚   â”‚   â””â”€â”€ update-product.dto.ts
â”‚   â”œâ”€â”€ entities
â”‚   â”‚   â””â”€â”€ product.entity.ts
â”‚   â”œâ”€â”€ products.controller.ts
â”‚   â”œâ”€â”€ products.service.ts
â”‚   â””â”€â”€ products.module.ts
â””â”€â”€ shared
    â”œâ”€â”€ storage
    â”‚   â””â”€â”€ oss.provider.ts
    â””â”€â”€ common
        â””â”€â”€ pipes
            â””â”€â”€ validation.ts
```
**æ ¸å¿ƒåŠŸèƒ½å®ç°é¡ºåº**

### å•†å“CRUD
``` js
// products.service.ts
@Injectable()
export class ProductsService {
  constructor(
    @InjectRepository(Product)
    private productsRepository: Repository<Product>,
  ) {}

  async paginate(options: IPaginationOptions): Promise<Pagination<Product>> {
    return paginate<Product>(this.productsRepository, options); // ä½¿ç”¨nestjs-paginate
  }
}
```
### å›¾ç‰‡ä¸Šä¼ 
``` js
// products.controller.ts
@Post('upload')
@UseInterceptors(FileInterceptor('file', {
  storage: diskStorage({
    destination: './uploads',
    filename: (req, file, cb) => {
      const suffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
      cb(null, `${file.fieldname}-${suffix}${extname(file.originalname)}`);
    },
  }),
}))
async uploadFile(@UploadedFile() file: Express.Multer.File) {
  return this.ossService.uploadToCloud(file.path);
}
```
### OpenAPIé›†æˆï¼ˆDay 3ï¼‰
``` js
// main.ts
const config = new DocumentBuilder()
  .setTitle('ç”µå•†ç®¡ç†API')
  .addBearerAuth()
  .setVersion('1.0')
  .build();

const document = SwaggerModule.createDocument(app, config);
SwaggerModule.setup('api-docs', app, document);
```
### æµ‹è¯•æ–¹æ¡ˆ
``` js
// products.e2e-spec.ts
describe('/products (GET)', () => {
  it('should return paginated results', () => {
    return request(app.getHttpServer())
      .get('/products?page=2&limit=10')
      .expect(200)
      .expect((res) => {
        expect(res.body.items).toBeInstanceOf(Array);
        expect(res.body.meta.totalItems).toBeGreaterThan(0);
      });
  });
});
```

### é˜¶æ®µä¸‰ï¼šæ•°æ®åº“å®æˆ˜ - ç”¨æˆ·ç§¯åˆ†ç³»ç»Ÿ
#### ğŸ—ƒï¸ å®ç°è·¯çº¿å›¾
Step 1ï¼šæ•°æ®åº“å»ºæ¨¡
``` sql
-- PostgreSQL Schema
CREATE TYPE transaction_type AS ENUM ('EARN', 'SPEND');

CREATE TABLE points_transaction (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  amount INTEGER CHECK (amount > 0),
  type transaction_type NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  -- å¤–é”®çº¦æŸ
  CONSTRAINT fk_user FOREIGN KEY(user_id) REFERENCES users(id)
);

CREATE INDEX idx_user_points ON points_transaction(user_id);
```
### Step 2ï¼šäº‹åŠ¡å¤„ç†æœåŠ¡
``` js
// points.service.ts
async function deductPoints(userId: string, points: number) {
  return this.dataSource.transaction(async (manager) => {
    // é”å®šç”¨æˆ·è¡Œ
    const user = await manager.findOne(User, {
      where: { id: userId },
      lock: { mode: 'pessimistic_write' }
    });

    if (user.points < points) throw new InsufficientPointsException();

    // åˆ›å»ºæ‰£å‡è®°å½•
    const transaction = manager.create(PointsTransaction, {
      userId,
      amount: points,
      type: 'SPEND'
    });
    
    // æ›´æ–°ç”¨æˆ·æ€»ç§¯åˆ†ï¼ˆé€šè¿‡è§¦å‘å™¨è‡ªåŠ¨ç»´æŠ¤ï¼‰
    return manager.save(transaction);
  });
}
```
### Step 3ï¼šæ¯æ—¥å¿«ç…§è®¾è®¡
``` js
// entities/daily-snapshot.entity.ts
@Entity()
export class DailySnapshot {

  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'date' })
  date: string;

  @Column({ type: 'jsonb' })
  data: {
    userId: string;
    totalPoints: number;
    transactionsCount: number;
  }[];

  @CreateDateColumn()
  createdAt: Date;
}

// è®¢é˜…æ•°æ®åº“äº‹ä»¶
@EventSubscriber()
export class PointsSubscriber implements EntitySubscriberInterface<PointsTransaction> {
  listenTo() {
    return PointsTransaction;
  }

  afterInsert() {
    // æ¯æ—¥0ç‚¹è§¦å‘å¿«ç…§ç”Ÿæˆ
    scheduleJob('0 0 * * *', () => this.generateSnapshot());
  }
}
```

### é˜¶æ®µå››ï¼šå®‰å…¨è®¤è¯ - SSOç³»ç»Ÿ
å®ç°æ­¥éª¤æ¡†æ¶
#### ğŸ”‘ åŒå› å­è®¤è¯æµç¨‹
``` markdown
sequenceDiagram
    participant User
    participant AuthService
    participant SMSService
    participant Redis

    User->>AuthService: æäº¤è´¦å·å¯†ç 
    AuthService->>AuthService: åŸºç¡€æ ¡éªŒ
    AuthService->>Redis: ç”ŸæˆtotpSecret(user:${id})
    AuthService->>SMSService: å‘é€çŸ­ä¿¡éªŒè¯ç (æ‰‹æœºå·)
    SMSService-->>User: æ¥æ”¶çŸ­ä¿¡
    User->>AuthService: æäº¤éªŒè¯ç 
    AuthService->>Redis: æ ¡éªŒéªŒè¯ç 
    AuthService->>AuthService: ç”ŸæˆJWTä»¤ç‰Œ
    AuthService-->>User: è¿”å›åŒä»¤ç‰Œ
```
å…³é”®ä»£ç æ¨¡å—
``` js
// 2faç­–ç•¥ç±»
@Injectable()
export class TwoFactorStrategy extends PassportStrategy(
  Strategy,
  '2fa' // è‡ªå®šä¹‰ç­–ç•¥åç§°
) {
  constructor(private redis: RedisService) {
    super({
      passReqToCallback: true,
    });
  }

  async validate(req: Request, payload: any) {
    const code = req.body?.code;
    const storedCode = await this.redis.get(`2fa:${payload.sub}`);

    if (!code || code !== storedCode) {
      throw new UnauthorizedException('éªŒè¯ç é”™è¯¯');
    }

    return { userId: payload.sub };
  }
}
```


### é˜¶æ®µäº”ï¼šç”Ÿäº§éƒ¨ç½²å®æˆ˜ï¼ˆç»­ï¼‰
#### äº‘åŸç”Ÿç”µå•†å¹³å°éƒ¨ç½²æ‰‹å†Œ
1. **æ­¥éª¤1ï¼šåŸºç¡€è®¾æ–½é…ç½®ï¼ˆTerraformï¼‰**
``` hcl
# infrastructure/main.tf
resource "aws_db_instance" "shop_db" {
  allocated_storage    = 20
  engine               = "postgres"
  instance_class       = "db.t3.micro"
  db_name              = "shop_production"
  username             = var.db_username
  password             = var.db_password
  skip_final_snapshot  = true
}

resource "aws_s3_bucket" "assets" {
  bucket = "shop-assets-${var.env}"
  acl    = "private"

  lifecycle {
    prevent_destroy = true
  }
}
```
2. **æ­¥éª¤2ï¼šå®¹å™¨ç¼–æ’ï¼ˆKubernetesï¼‰**
``` yaml
# hpa.yaml è‡ªåŠ¨æ‰©ç¼©å®¹é…ç½®
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: shop-api
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: shop-backend
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 60
```
3. **æ­¥éª¤3ï¼šç›‘æ§å‘Šè­¦ï¼ˆPrometheus + Grafanaï¼‰**
``` yaml
# prometheus-alert.yaml
- alert: HighErrorRate
  expr: sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m])) > 0.05
  for: 10m
  labels:
    severity: critical
  annotations:
    summary: "High error rate detected"
    description: "Error rate exceeding 5% for service {{ $labels.service }}"
```

### é˜¶æ®µå…­ï¼šç”Ÿæ€æ‰©å±• - å®æ—¶åä½œç™½æ¿
#### WebSocketå®æ—¶é€šä¿¡å®æˆ˜æ­¥éª¤
é¡¹ç›®åˆå§‹åŒ–
``` sh
nest g resource whiteboard --ws
npm install @nestjs/websockets @nestjs/platform-ws socket.io
```
æ ¸å¿ƒæ¨¡å—å®ç°
1. **ä¿¡ä»¤æœåŠ¡ï¼ˆæ ¸å¿ƒé€»è¾‘ï¼‰**
``` js
// whiteboard.gateway.ts
@WebSocketGateway({
  cors: {
    origin: process.env.CLIENT_URL,
    methods: ["GET", "POST"]
  }
})
export class WhiteboardGateway {
  @WebSocketServer()
  server: Server;

  private userRooms = new Map<string, string>();

  @SubscribeMessage('joinRoom')
  handleJoinRoom(client: Socket, roomId: string): void {
    client.join(roomId);
    this.userRooms.set(client.id, roomId);
  }

  @SubscribeMessage('draw')
  handleDrawEvent(client: Socket, data: DrawData): void {
    const roomId = this.userRooms.get(client.id);
    client.to(roomId).emit('draw', data); // å¹¿æ’­ç»˜åˆ¶äº‹ä»¶
  }
}
```
2. **çŠ¶æ€åŒæ­¥ï¼ˆRedisé€‚é…ï¼‰**
``` js
// redis-adapter.ts
import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { Redis } from 'ioredis';

export const configureRedisAdapter = (io: Server) => {
  const pubClient = new Redis(process.env.REDIS_URL);
  const subClient = pubClient.duplicate();
  io.adapter(createAdapter(pubClient, subClient));
};
```
å‰ç«¯è”è°ƒè„šæœ¬
``` js
// å‰ç«¯è¿æ¥ç¤ºä¾‹
const socket = io(API_URL, {
  auth: {
    token: localStorage.getItem('jwt')
  }
});

// ç»˜åˆ¶äº‹ä»¶ç›‘å¬
canvas.addEventListener('draw', (event) => {
  socket.emit('draw', {
    x: event.clientX,
    y: event.clientY,
    color: selectedColor
  });
});
```
å…³é”®æŠ€æœ¯æŒ‘æˆ˜ï¼š

   - æ•°æ®åŒæ­¥å»æŠ–åŠ¨ï¼ˆäº‹ä»¶åˆå¹¶ä¼˜åŒ–ï¼‰
   - ç¦»çº¿æ¢å¤æœºåˆ¶ï¼ˆæ“ä½œæ—¥å¿—é‡æ”¾ï¼‰
   - å†²çªè§£å†³ç­–ç•¥ï¼ˆOTç®—æ³•åŸºç¡€å®ç°ï¼‰

### é˜¶æ®µå…­ï¼šç”Ÿæ€æ‰©å±• - å¾®æœåŠ¡æ”¯ä»˜ç³»ç»Ÿ
#### gRPCå¾®æœåŠ¡å®ç°æŒ‡å—
Protoæ–‡ä»¶å®šä¹‰
``` protobuf
// payment.proto
syntax = "proto3";

package payment;

service PaymentService {
  rpc ProcessPayment (PaymentRequest) returns (PaymentResponse) {}
}

message PaymentRequest {
  string order_id = 1;
  double amount = 2;
  string currency = 3;
}

message PaymentResponse {
  string transaction_id = 1;
  enum Status {
    SUCCESS = 0;
    DECLINED = 1;
    PENDING = 2;
  }
  Status status = 2;
}
```
æœåŠ¡ç«¯å®ç°
``` ts
// payment.service.ts
@GrpcMethod('PaymentService', 'ProcessPayment')
async processPayment(data: PaymentRequest): Promise<PaymentResponse> {
  const result = await this.paymentGateway.charge(data);
  
  return {
    transaction_id: result.id,
    status: result.success ? 
      Payment_Status.SUCCESS : 
      Payment_Status.DECLINED
  };
}
```
å®¢æˆ·ç«¯è°ƒç”¨
``` ts
// order.service.ts
@Client({
  transport: Transport.GRPC,
  options: {
    package: 'payment',
    protoPath: join(__dirname, '../payment.proto'),
  }
})
private client: ClientGrpc;

private paymentService: PaymentService;

onModuleInit() {
  this.paymentService = this.client.getService<PaymentService>('PaymentService');
}

async completeOrder(orderId: string) {
  const response = await this.paymentService.processPayment({
    order_id: orderId,
    amount: 99.99,
    currency: 'USD'
  }).toPromise();
  
  if (response.status === Payment_Status.SUCCESS) {
    this.orderRepository.markAsPaid(orderId);
  }
}
```
ç†”æ–­æœºåˆ¶é…ç½®ï¼š
``` ts
// circuit-breaker.config.ts
export const paymentServiceCircuitBreaker = new CircuitBreaker({
  timeout: 3000, // 3ç§’æ— å“åº”è§¦å‘è¶…æ—¶
  errorThresholdPercentage: 50, // 50%å¤±è´¥åæ‰“å¼€æ–­è·¯å™¨
  resetTimeout: 30000 // 30ç§’åè¿›å…¥åŠå¼€çŠ¶æ€
});
```

å…¨è®¡åˆ’æ¨è¿›è·¯çº¿å›¾
``` mermaid
    gantt
    title å…¨æ ˆå¼€å‘å­¦ä¹ ç”˜ç‰¹å›¾
    dateFormat  YYYY-MM-DD
    section Node.js
    æ ¸å¿ƒæœºåˆ¶å­¦ä¹        :active, 2024-03-01, 15d
    ç½‘ç»œä¸æµå¤„ç†       :2024-03-16, 14d
    
    section NestJS
    æ¡†æ¶æ¶æ„ç ”ä¿®       :2024-04-01, 10d
    ç”µå•†ç®¡ç†é¡¹ç›®       :2024-04-11, 18d
    
    section éƒ¨ç½²è¿ç»´
    å®¹å™¨åŒ–å®è·µ        :2024-05-01, 7d
    K8sç”Ÿäº§éƒ¨ç½²       :2024-05-08, 14d
    
    section é«˜çº§æ‹“å±•
    å¾®æœåŠ¡æ‹†è§£        :2024-06-01, 21d
    å®æ—¶é€šä¿¡ä¼˜åŒ–       :2024-06-22, 14d
```

æ¯ä¸ªå®æˆ˜é¡¹ç›®å‡æä¾›å®Œæ•´ä»£ç ä»“åº“æ¨¡æ¿ï¼ˆè®¿é—®å…¨æ ˆæ¡ˆä¾‹åº“è·å–æºç ï¼‰ï¼Œå»ºè®®æŒ‰é˜¶æ®µå®Œæˆè¿›åŒ–
é˜¶æ®µéªŒæ”¶ï¼šæ¯ä¸ªé¡¹ç›®å®ç°70%åŸºç¡€åŠŸèƒ½å³è®¤å¯é€šè¿‡
é¡¹ç›®è¿­ä»£ï¼šä¿ç•™æ¯ä¸ªç‰ˆæœ¬çš„Git Tagä»¥ä¾¿ä»£ç å›æº¯
æŠ€æœ¯å€ºåŠ¡ï¼šå»ºç«‹ä¸“é—¨çš„tech-debt.mdè®°å½•å¾…ä¼˜åŒ–é¡¹
ä¿æŒæ¯å®Œæˆä¸€ä¸ªé¡¹ç›®æ’°å†™ä¸€ç¯‡æŠ€æœ¯åšå®¢ï¼Œæ„å»ºå®Œæ•´å­¦ä¹ è½¨è¿¹ï¼ âœ¨

